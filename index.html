<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Recipe 1: Grand Prix Ultimate Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }
        
        /* UI Layer */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* HUD CONTAINERS */
        .hud-container { position: absolute; top: 0; height: 100%; pointer-events: none; }
        #p1-hud { left: 0; width: 100%; }
        #p2-hud { right: 0; width: 50%; display: none; border-left: 2px solid #000; }

        /* HUD PANELS */
        .hud-panel { position: absolute; padding: 10px 15px; background: rgba(0,0,0,0.8); color: white; border-left: 4px solid #e63946; font-weight: bold; font-family: monospace; font-size: 20px; skew: -10deg; }
        
        #p1-stats { top: 20px; left: 20px; }
        #p1-times { top: 20px; right: 20px; text-align: right; border-left: none; border-right: 4px solid #e63946; }
        #p1-speedometer { position: absolute; bottom: 20px; right: 20px; width: 240px; height: 120px; background: linear-gradient(to top, rgba(0,0,0,0.9), transparent); border-bottom: 4px solid #e63946; text-align: right; padding: 10px; box-sizing: border-box; }
        
        #p2-stats { top: 20px; left: 20px; border-left-color: #00f5d4; }
        #p2-times { top: 20px; right: 20px; text-align: right; border-left: none; border-right: 4px solid #00f5d4; }
        #p2-speedometer { position: absolute; bottom: 20px; right: 20px; width: 240px; height: 120px; background: linear-gradient(to top, rgba(0,0,0,0.9), transparent); border-bottom: 4px solid #00f5d4; text-align: right; padding: 10px; box-sizing: border-box; }

        .speed-val { font-size: 50px; color: #fff; font-family: monospace; font-weight: 900; }
        .speed-unit { font-size: 14px; color: #aaa; }
        .gear-disp { font-size: 30px; color: yellow; float: left; font-weight: bold; margin-top: 15px; margin-left: 10px; }

        .warning-box {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(0,0,0,0.8); color: white; padding: 10px 20px;
            font-family: monospace; font-weight: bold; font-size: 18px;
            border-left: 4px solid orange; transform: skew(-10deg);
        }

        /* Menus */
        #main-menu, #pause-menu, #results-menu, #champ-menu, #leaderboard-view, #multiplayer-menu, #settings-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.65);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 10;
        }
        
        #pause-menu { background: rgba(0,0,0,0.85); backdrop-filter: blur(5px); }
        #results-menu, #champ-menu, #leaderboard-view, #multiplayer-menu, #settings-menu { background: rgba(0,0,0,0.9); backdrop-filter: blur(10px); }
        
        .result-box {
            border: 2px solid #444; background: #222; padding: 40px; text-align: center;
            width: 450px; transform: skew(-5deg); box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .result-pos { font-size: 80px; font-weight: 900; color: #e63946; margin: 0; line-height: 1; }
        .result-label { color: #888; font-size: 14px; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 5px; }
        .result-time { font-family: monospace; font-size: 30px; color: white; margin-bottom: 20px; }
        
        .career-stat { font-size: 20px; color: #ffd700; margin-top: 10px; border-top: 1px solid #444; padding-top: 10px; }

        h1 { color: #fff; font-size: 70px; font-style: italic; text-transform: uppercase; margin: 0; text-shadow: 4px 4px #e63946; letter-spacing: 5px; }
        h2 { color: #aaa; font-size: 40px; margin-bottom: 30px; text-transform: uppercase; font-style: italic; }
        h3 { color: #fff; font-size: 24px; text-transform: uppercase; margin: 0 0 10px 0; font-style: italic; border-bottom: 2px solid #555; padding-bottom: 5px; }

        .menu-row { display: flex; gap: 30px; margin: 20px 0; align-items: flex-start; }
        .menu-col { display: flex; flex-direction: column; gap: 10px; }
        
        select, button {
            padding: 15px 30px; font-size: 18px; background: #333; color: white; border: 2px solid #555;
            cursor: pointer; font-family: inherit; text-transform: uppercase; font-weight: bold; width: 250px;
        }
        select:hover, button:hover { border-color: #e63946; background: #444; }
        
        .team-desc {
            width: 250px; min-height: 80px; background: #222; border: 1px solid #444; color: #ccc;
            padding: 10px; font-size: 14px; line-height: 1.4; font-style: italic;
        }
        
        .record-notification {
            position: absolute; top: 15%; left: 50%; transform: translate(-50%, -50%);
            font-size: 60px; font-weight: 900; color: #00ff00;
            text-shadow: 0 0 20px rgba(0,255,0,0.8);
            display: none; font-style: italic; z-index: 20;
        }
        
        .career-info {
            position: absolute; top: 20px; width: 100%; text-align: center;
            font-size: 24px; color: #ffd700; font-weight: bold; text-shadow: 2px 2px 0 #000;
            font-style: italic; pointer-events: none;
        }
        
        .dev-badge {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.7); padding: 5px 15px; color: white;
            font-family: monospace; font-weight: bold; pointer-events: none;
            display: none; border-radius: 4px;
        }

        .btn-start { background: #e63946; border: none; font-size: 24px; padding: 20px 60px; transform: skew(-10deg); box-shadow: 0 0 20px rgba(230, 57, 70, 0.5); width: auto; margin-top: 20px; }
        .btn-start:hover { background: #ff4d5a; transform: skew(-10deg) scale(1.05); }

        .btn-career { background: #ffd700; color: #000; border: none; font-size: 24px; padding: 20px 60px; transform: skew(-10deg); box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); width: auto; margin-top: 20px; margin-left: 20px; }
        .btn-career:hover { background: #ffea00; transform: skew(-10deg) scale(1.05); }

        .btn-multi { background: #00f5d4; color: #000; border: none; font-size: 24px; padding: 20px 60px; transform: skew(-10deg); box-shadow: 0 0 20px rgba(0, 245, 212, 0.5); width: auto; margin-top: 20px; margin-left: 20px; }
        .btn-multi:hover { background: #55ffea; transform: skew(-10deg) scale(1.05); }

        /* MP Menu Specifics */
        .mp-box {
            background: #222; border: 1px solid #555; padding: 20px;
            display: flex; flex-direction: column; gap: 10px;
        }
        .mp-label { color: #888; font-size: 14px; letter-spacing: 1px; }

        /* Leaderboard */
        .leaderboard-container { max-height: 80%; overflow-y: auto; background: #222; border: 2px solid #555; padding: 10px; box-shadow: 0 10px 40px rgba(0,0,0,0.8); }
        table.leaderboard { width: 600px; border-collapse: collapse; color: white; font-family: monospace; font-size: 18px; }
        table.leaderboard th { background: #e63946; padding: 12px; text-align: left; position: sticky; top: 0; }
        table.leaderboard td { padding: 10px; border-bottom: 1px solid #333; }
        table.leaderboard tr:nth-child(even) { background: #2a2a2a; }
        table.leaderboard tr.player-row { background: #2d4a2d; border-left: 4px solid #00ff00; }

        /* Settings UI */
        .btn-settings {
            position: absolute; bottom: 20px; right: 20px;
            background: #333; border: 2px solid #555; color: #ccc;
            font-size: 24px; width: 60px; height: 60px; border-radius: 50%;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s; box-shadow: 0 4px 10px rgba(0,0,0,0.5); z-index: 50;
        }
        .btn-settings:hover { background: #444; color: white; transform: rotate(90deg); }

        .settings-content {
            display: flex; flex-direction: column; gap: 20px; width: 500px;
        }
        .setting-row {
            display: flex; justify-content: space-between; align-items: center;
            background: #222; padding: 15px; border-left: 4px solid #555;
        }
        .setting-label { font-size: 18px; font-weight: bold; color: #eee; }
        
        input[type=range] { width: 200px; accent-color: #e63946; }
        input[type=checkbox] { width: 25px; height: 25px; accent-color: #e63946; cursor: pointer; }

        #center-msg { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 90px; font-weight: 900; color: yellow; text-shadow: 4px 4px 0 #000; text-align: center; font-style: italic; z-index: 50; }
        #penalty-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 0, 0, 0.3); display: none; display: flex; align-items: center; justify-content: center; color: white; font-size: 40px; font-weight: 900; font-style: italic; text-shadow: 2px 2px 0 #000; z-index: 5; }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="main-menu">
    <h1>Recipe 1: Grand Prix</h1>
    <div style="color:#888; margin-bottom: 20px;">v5.2 - DYNAMIC CAMERA</div>
    
    <div class="menu-row">
        <div class="menu-col">
            <label style="color:#aaa; font-size:14px;">CIRCUIT</label>
            <select id="map-select">
                <option value="SILVERSTONE">Silverstone (UK)</option>
                <option value="SPA">Spa (Belgium)</option>
                <option value="MONZA">Monza (Italy)</option>
                <option value="SUZUKA">Suzuka (Japan)</option>
                <option value="AUSTRIA">Austria (Red Bull Ring)</option>
                <option value="INTERLAGOS">Interlagos (Brazil)</option>
                <option value="MONTREAL" selected>Montreal (Canada)</option>
            </select>

            <label style="color:#aaa; font-size:14px; margin-top: 10px;">DIFFICULTY & RULES</label>
            <select id="diff-select">
                <option value="ROOKIE">Rookie (No Penalties)</option>
                <option value="PRO" selected>Pro (5s Stop Penalty)</option>
                <option value="LEGEND">Legend (10s Stop Penalty)</option>
            </select>
        </div>

        <div class="menu-col">
            <label style="color:#aaa; font-size:14px;">SELECT TEAM (P1)</label>
            <select id="team-select" onchange="updateTeamDesc()">
                </select>
            <div id="team-desc-box" class="team-desc"></div>
        </div>
    </div>

    <div>
        <button class="btn-start" onclick="startGame(true)">QUICK RACE</button>
        <button class="btn-career" onclick="startCareer()">START CAREER</button>
        <button class="btn-multi" onclick="openMultiplayerMenu()">2 PLAYER RACE</button>
    </div>
    
    <button class="btn-settings" onclick="openSettings()">âš™</button>
    
    <div style="margin-top: 30px; font-size: 16px; color: #666; font-family: monospace; letter-spacing: 1px;">
        Made by 24009620
    </div>
</div>

<div id="settings-menu" class="hidden">
    <h1>SETTINGS</h1>
    <div class="settings-content">
        <div class="setting-row">
            <span class="setting-label">MASTER VOLUME</span>
            <input type="range" min="0" max="100" value="50" oninput="updateVolume(this.value)">
        </div>
        
        <div class="setting-row">
            <span class="setting-label">DYNAMIC CAMERA</span>
            <input type="checkbox" id="cam-rotate" onchange="toggleCameraRotation(this.checked)">
        </div>
        
        <div class="setting-row">
            <span class="setting-label">DRAW DECORATIONS</span>
            <input type="checkbox" id="gfx-decor" checked onchange="toggleDecorations(this.checked)">
        </div>

        <div class="setting-row" style="flex-direction: column; gap: 10px; align-items: stretch;">
            <button onclick="downloadRecords()" style="width: 100%; font-size: 16px; padding: 10px;">DOWNLOAD LAP RECORDS (CSV)</button>
            <button onclick="clearGhostData()" style="width: 100%; font-size: 16px; padding: 10px; background:#e63946;">CLEAR GHOST DATA</button>
            <button onclick="clearAllData()" style="width: 100%; font-size: 16px; padding: 10px; background:#333; color:#aaa;">RESET SAVE DATA</button>
        </div>

        <div class="setting-row" style="display:block; text-align:center; color:#888; font-size:14px;">
            <div style="margin-bottom:5px;"><strong style="color:white;">P1:</strong> WASD (Move)</div>
            <div><strong style="color:white;">P2:</strong> ARROW KEYS (Move)</div>
        </div>
    </div>
    <button onclick="closeSettings()" style="margin-top:20px; width: 200px;">BACK</button>
</div>

<div id="multiplayer-menu" class="hidden">
    <h1 style="color:#00f5d4; font-size: 60px;">MULTIPLAYER SETUP</h1>
    
    <div class="menu-row">
        <div class="menu-col" style="align-items: center;">
            <label style="color:#aaa; font-size:14px;">CIRCUIT</label>
            <select id="mp-map-select" style="width: 300px; border-color: #00f5d4;">
                <option value="SILVERSTONE">Silverstone (UK)</option>
                <option value="SPA">Spa (Belgium)</option>
                <option value="MONZA">Monza (Italy)</option>
                <option value="SUZUKA">Suzuka (Japan)</option>
                <option value="AUSTRIA">Austria (Red Bull Ring)</option>
                <option value="INTERLAGOS">Interlagos (Brazil)</option>
                <option value="MONTREAL" selected>Montreal (Canada)</option>
            </select>
        </div>
    </div>

    <div class="menu-row">
        <div class="mp-box" style="border-left: 4px solid #e63946;">
            <h3>PLAYER 1</h3>
            <span class="mp-label">CONTROLS: WASD</span>
            <select id="mp-p1-team" onchange="updateMPTeamColors()"></select>
            <div id="mp-p1-preview" style="height: 10px; width: 100%; background: #333; margin-top:5px;"></div>
        </div>

        <div class="mp-box" style="border-right: 4px solid #00f5d4;">
            <h3 style="text-align: right;">PLAYER 2</h3>
            <span class="mp-label" style="text-align: right;">CONTROLS: ARROW KEYS</span>
            <select id="mp-p2-team" onchange="updateMPTeamColors()"></select>
            <div id="mp-p2-preview" style="height: 10px; width: 100%; background: #333; margin-top:5px;"></div>
        </div>
    </div>

    <div style="margin-top: 20px;">
        <button class="btn-multi" onclick="startMultiplayerRace()">START RACE</button>
        <button onclick="showMenu()" style="background:#444; border:none; margin-left: 20px;">BACK</button>
    </div>
</div>

<div id="pause-menu" class="hidden">
    <h2>RACE PAUSED</h2>
    <button onclick="togglePause()">RESUME</button>
    <button onclick="openSettings()" style="margin-top: 10px; background:#333;">SETTINGS</button>
    <button onclick="showMenu()" style="margin-top: 10px;">MAIN MENU</button>
    <button class="btn-settings" style="bottom: 20px; right: 20px;" onclick="openSettings()">âš™</button>
</div>

<div id="results-menu" class="hidden">
    <h1>FINISHED</h1>
    <div class="result-box">
        <div class="result-label">POSITION</div>
        <div id="res-pos" class="result-pos">P1</div>
        <br>
        <div class="result-label">TOTAL TIME</div>
        <div id="res-time" class="result-time">0:00.00</div>
        
        <div class="result-label">BEST LAP</div>
        <div id="res-best" class="result-time" style="color:#aaa; font-size: 24px;">0:00.00</div>
        
        <div id="career-result-panel" class="hidden">
            <div class="career-stat">
                POINTS GAINED: <span id="res-pts" style="color:#fff;">+25</span>
            </div>
            <div style="font-size:16px; color:#aaa; margin-top:5px;">
                TOTAL CHAMPIONSHIP: <span id="res-total-pts" style="color:#fff;">125</span>
            </div>
        </div>
    </div>
    <div style="margin-top: 20px;">
        <button id="btn-restart" onclick="restartRace()">RESTART</button>
        <button id="btn-standings" class="hidden" style="background:#222; border-color:#888;" onclick="toggleLeaderboard()">STANDINGS</button>
        <button id="btn-next" class="hidden" style="background: #ffd700; color:black;" onclick="nextCareerRace()">NEXT RACE</button>
        <button onclick="showMenu()" style="background:#444; margin-left:10px;">MENU</button>
    </div>
</div>

<div id="leaderboard-view" class="hidden">
    <h2 style="color:#ffd700; margin-bottom: 20px;">CHAMPIONSHIP STANDINGS</h2>
    <div class="leaderboard-container">
        <table class="leaderboard">
            <thead>
                <tr>
                    <th style="width: 50px;">#</th>
                    <th>DRIVER</th>
                    <th>TEAM</th>
                    <th style="text-align: right;">PTS</th>
                </tr>
            </thead>
            <tbody id="leaderboard-body"></tbody>
        </table>
    </div>
    <button onclick="toggleLeaderboard()" style="margin-top: 20px;">CLOSE</button>
</div>

<div id="champ-menu" class="hidden">
    <h1 style="color:#ffd700">SEASON COMPLETE</h1>
    <div class="result-box">
        <div class="result-label">WORLD CHAMPION</div>
        <div id="champ-name" class="result-pos" style="font-size:50px; color:#ffd700;">PLAYER</div>
        <br>
        <div class="result-label">TOTAL POINTS</div>
        <div id="champ-points" class="result-time">0</div>
        
        <div style="border-top:1px solid #555; padding-top:10px; margin-top:10px;">
            <button onclick="toggleLeaderboard()" style="background:#222; font-size:16px;">VIEW FULL STANDINGS</button>
        </div>
    </div>
    <button onclick="showMenu()" style="margin-top:20px;">MAIN MENU</button>
</div>

<div id="ui-layer" class="hidden">
    <div id="dev-recording-ui" class="dev-badge">ðŸ”´ REC</div>
    <div id="career-overlay" class="career-info hidden">ROUND 1/7</div>

    <div id="penalty-overlay" class="hidden">
        <div>
            PENALTY<br>
            <span id="penalty-timer" style="font-size:60px; color:yellow;">5.0</span>s
        </div>
    </div>
    
    <div id="new-record-msg" class="record-notification">NEW LAP RECORD!</div>

    <div id="p1-hud" class="hud-container">
        <div id="p1-stats" class="hud-panel">
            POS: <span id="p1-pos-disp">--</span>/16<br>
            LAP: <span id="p1-lap-disp">1</span>/5
        </div>
        <div id="p1-times" class="hud-panel">
            TIME: <span id="p1-cur-time">0.00</span><br>
            LAST: <span id="p1-last-lap">--:--</span><br>
            <div style="border-top:2px solid #555; margin-top:5px; padding-top:5px; color:#aaa; font-size:16px;">
                REC: <span id="track-record">--:--</span>
            </div>
        </div>
        <div id="p1-speedometer">
            <div class="gear-disp" id="p1-gear">N</div>
            <span class="speed-val" id="p1-speed">0</span> <span class="speed-unit">KM/H</span>
        </div>
        <div id="p1-warning-box" class="warning-box" style="bottom: 240px;"> 
            WARNINGS: <span id="p1-warn-count">0</span>/<span id="p1-warn-limit">5</span>
        </div>
    </div>

    <div id="p2-hud" class="hud-container">
        <div id="p2-stats" class="hud-panel">
            POS: <span id="p2-pos-disp">--</span>/16<br>
            LAP: <span id="p2-lap-disp">1</span>/5
        </div>
        <div id="p2-times" class="hud-panel">
            TIME: <span id="p2-cur-time">0.00</span><br>
            LAST: <span id="p2-last-lap">--:--</span>
        </div>
        <div id="p2-speedometer">
            <div class="gear-disp" id="p2-gear">N</div>
            <span class="speed-val" id="p2-speed">0</span> <span class="speed-unit">KM/H</span>
        </div>
        <div id="p2-warning-box" class="warning-box" style="bottom: 240px;"> 
            WARNINGS: <span id="p2-warn-count">0</span>/5
        </div>
    </div>

    <div id="center-msg"></div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/** AUDIO SETUP */
const audioMenu = new Audio('formula-1-theme-8-bit.mp3');
audioMenu.loop = true;
audioMenu.volume = 0.5;

const audioRace = new Audio('grand-prix.mp3');
audioRace.loop = true;
audioRace.volume = 0.4;

/** CONSTANTS & CONFIG */
const TOTAL_LAPS = 5;
const TOTAL_CARS = 16;
const TRACK_WIDTH = 150; 
const BASE_FRICTION_ROAD = 0.98; 
const BASE_FRICTION_GRASS = 0.88; 
const BASE_ACCEL = 0.2;
const BASE_MAX_SPEED = 16;
const BASE_TURN_SPEED = 0.065;

// FPS CAP VARIABLES
const FPS = 60;
const FRAME_INTERVAL = 1000 / FPS;
let lastFrameTime = Date.now();

const CAREER_ORDER = ["SILVERSTONE", "SPA", "MONZA", "SUZUKA", "AUSTRIA", "INTERLAGOS", "MONTREAL"];
const POINTS_SYSTEM = [25, 18, 15, 12, 10, 8, 6, 4, 2, 1]; 

let isCareerMode = false;
let isMultiplayer = false;
let careerIndex = 0;
let careerScores = new Array(TOTAL_CARS).fill(0); 
let careerParticipants = []; 

let selectedTeamId = 1;
let selectedP2TeamId = 1; // For MP
let currentMapKey = "SILVERSTONE";

let trackRecords = {};
let decorations = []; 
let racingLine = []; // AI Path

// Settings State
let drawDecorationsEnabled = true;
let cameraRotationEnabled = false;
let previousMenuState = 'MENU';

// --- GHOST SYSTEM ---
let currentLapRecording = [];
let ghostData = null; // Loaded ghost data for current map

function loadRecords() {
    const data = localStorage.getItem('jsgp_records');
    if (data) {
        trackRecords = JSON.parse(data);
    }
}

function saveRecords() {
    localStorage.setItem('jsgp_records', JSON.stringify(trackRecords));
}

function saveGhost(trackKey, recording) {
    if(recording.length > 100) { 
        const optimized = recording.filter((_, i) => i % 3 === 0);
        localStorage.setItem('jsgp_ghost_' + trackKey, JSON.stringify(optimized));
        console.log("Ghost saved for " + trackKey);
        loadGhost(trackKey);
    }
}

function loadGhost(trackKey) {
    const raw = localStorage.getItem('jsgp_ghost_' + trackKey);
    if(raw) {
        ghostData = JSON.parse(raw);
        console.log("Ghost loaded for " + trackKey);
        return true;
    }
    ghostData = null;
    return false;
}

// --- SETTINGS FUNCTIONS ---
function openSettings() {
    // Determine which menu to go back to
    if (!document.getElementById('main-menu').classList.contains('hidden')) {
        previousMenuState = 'MAIN';
    } else if (!document.getElementById('pause-menu').classList.contains('hidden')) {
        previousMenuState = 'PAUSE';
    } else {
        // Fallback or if opened during race directly (not implemented via button but safety check)
        previousMenuState = 'MAIN';
    }

    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('pause-menu').classList.add('hidden');
    document.getElementById('settings-menu').classList.remove('hidden');
}

function closeSettings() {
    document.getElementById('settings-menu').classList.add('hidden');
    
    if (previousMenuState === 'MAIN') {
        document.getElementById('main-menu').classList.remove('hidden');
    } else if (previousMenuState === 'PAUSE') {
        document.getElementById('pause-menu').classList.remove('hidden');
    }
}

function updateVolume(val) {
    let v = val / 100;
    audioMenu.volume = v;
    audioRace.volume = v;
}

function toggleDecorations(checked) {
    drawDecorationsEnabled = checked;
}

function toggleCameraRotation(checked) {
    cameraRotationEnabled = checked;
}

function clearGhostData() {
    if(confirm("Clear GHOST DATA only? Records will remain.")) {
        for(let key in MAPS) {
            localStorage.removeItem('jsgp_ghost_' + key);
        }
        ghostData = null;
        alert("Ghost data cleared.");
    }
}

function clearAllData() {
    if(confirm("FULL RESET: This will delete ALL lap records and ghost data. Are you sure?")) {
        localStorage.clear();
        trackRecords = {};
        ghostData = null;
        location.reload();
    }
}

function formatTime(t) {
    if(!t || t === 9999) return "--:--";
    let mins = Math.floor(t / 60);
    let secs = (t % 60).toFixed(2);
    return (mins > 0 ? mins + ":" : "") + (secs < 10 && mins > 0 ? "0" : "") + secs;
}

function checkRecord(trackName, time) {
    if (!trackRecords[trackName] || time < trackRecords[trackName]) {
        trackRecords[trackName] = time;
        saveRecords();
        return true;
    }
    return false;
}

function downloadRecords() {
    let csvContent = "data:text/csv;charset=utf-8,Track,Best Lap Time (Seconds)\n";
    for(let key in MAPS) {
        let time = trackRecords[key] ? trackRecords[key].toFixed(3) : "No Record";
        csvContent += `${key},${time}\n`;
    }
    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "js_grand_prix_records.csv");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

loadRecords(); 

/** TEAMS DATA */
const TEAMS = [
    { id: 0, name: "Scuderia Rosso", color: "#d90429", speed: 1.01, handling: 1.00, grip: 1.00, desc: "<span class='stat-good'>Balanced Spec</span><br>Slight edge on straights." },
    { id: 1, name: "Cyan Arrow", color: "#00f5d4", speed: 1.00, handling: 1.00, grip: 1.00, desc: "<span class='stat-good'>Balanced Spec</span><br>Standard setup." },
    { id: 2, name: "Bull Racing", color: "#001d3d", speed: 1.005, handling: 1.005, grip: 1.00, desc: "<span class='stat-good'>Balanced Spec</span><br>Very agile." },
    { id: 3, name: "Papaya Speed", color: "#fb8500", speed: 1.01, handling: 0.99, grip: 1.00, desc: "<span class='stat-good'>Balanced Spec</span><br>Aggressive gearing." },
    { id: 4, name: "Verde Martin", color: "#006400", speed: 1.00, handling: 1.01, grip: 1.00, desc: "<span class='stat-good'>Balanced Spec</span><br>Good turn-in." },
    { id: 5, name: "Alpine Blue", color: "#4361ee", speed: 1.00, handling: 1.00, grip: 1.00, desc: "<span class='stat-good'>Balanced Spec</span><br>Standard setup." },
    { id: 6, name: "Violet GP", color: "#7209b7", speed: 0.99, handling: 1.01, grip: 1.01, desc: "<span class='stat-good'>Balanced Spec</span><br>High Downforce." },
    { id: 7, name: "Sunny F1", color: "#ffea00", speed: 1.00, handling: 0.99, grip: 1.01, desc: "<span class='stat-good'>Balanced Spec</span><br>Reliable." }
];

/** MAPS */
const MAPS = {
    "SILVERSTONE": [
        {x:0, y:-1000}, {x:200, y:-1400}, {x:600, y:-1400}, 
        {x:800, y:-1100}, {x:1000, y:-1400}, {x:1200, y:-1100}, 
        {x:1600, y:-1100}, {x:2000, y:-800}, {x:2000, y:-400}, 
        {x:1500, y:-400}, {x:1200, y:-100}, {x:800, y:-400}, 
        {x:0, y:800}, {x:0, y:0}
    ],
    "SPA": [
        {x:0, y:-100}, {x:300, y:-400}, {x:300, y:0}, {x:0, y:400}, 
        {x:-400, y:800}, {x:-400, y:1200}, {x:-200, y:1400}, {x:0, y:1600}, 
        {x:1000, y:2000}, {x:1400, y:1800}, {x:1600, y:2000}, {x:1400, y:2200}, 
        {x:400, y:2200}, {x:-200, y:2000}, {x:-400, y:2200}, 
        {x:0, y:1000}, {x:0, y:0}
    ],
    "MONZA": [
        {x:0, y:-1500}, {x:200, y:-1800}, {x:400, y:-1500}, 
        {x:600, y:-1200}, {x:1200, y:-1200}, {x:1400, y:-1000}, {x:1200, y:-800}, 
        {x:800, y:0}, {x:600, y:200}, {x:400, y:0}, {x:200, y:200}, 
        {x:-200, y:400}, {x:-600, y:200}, {x:0, y:1000}, {x:0, y:0}
    ],
    "SUZUKA": [
        {x:0, y:-800}, {x:400, y:-1000}, {x:600, y:-800}, {x:800, y:-1000}, {x:1000, y:-800}, 
        {x:1200, y:-1200}, {x:1400, y:-1000}, {x:1400, y:-600}, {x:1000, y:-600}, 
        {x:600, y:-400}, {x:1200, y:0}, {x:1600, y:200}, {x:1400, y:600}, 
        {x:200, y:400}, {x:-100, y:600}, {x:-300, y:400}, {x:0, y:800}, {x:0, y:0}
    ],
    "AUSTRIA": [ 
        {x:0, y:-800}, {x:200, y:-1000}, {x:600, y:-1000}, 
        {x:1200, y:-1200}, {x:1400, y:-1000}, 
        {x:1200, y:-400}, {x:1000, y:-200}, 
        {x:600, y:-200}, {x:400, y:-400}, {x:200, y:-200}, 
        {x:0, y:600}, {x:0, y:0}
    ],
    "INTERLAGOS": [ 
        {x:0, y:-600}, {x:-200, y:-800}, {x:0, y:-1000}, {x:200, y:-800}, 
        {x:200, y:0}, {x:600, y:200}, {x:800, y:0}, 
        {x:1000, y:200}, {x:1200, y:0}, 
        {x:800, y:-400}, {x:600, y:-200}, 
        {x:-400, y:400}, 
        {x:0, y:600}, {x:0, y:0}
    ],
    "MONTREAL": [ 
        {x: 600, y: 0}, 
        {x: 1000, y: 0},
        {x: 1200, y: -100}, {x: 1200, y: -300}, {x: 1000, y: -400},
        {x: 800, y: -400}, {x: 800, y: -700}, 
        {x: 500, y: -700}, {x: 500, y: -1100}, 
        {x: 300, y: -1200}, {x: 100, y: -1100}, {x: 200, y: -900},
        {x: 0, y: -1000}, {x: -200, y: -1200}, {x: -400, y: -1100}, 
        {x: -500, y: -900}, {x: -400, y: -700}, 
        {x: -200, y: -500}, {x: -300, y: -300},
        {x: -600, y: -200}, {x: -700, y: 0},
        {x: 0, y: 0}
    ]
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

// State Variables
let keys = { w: false, a: false, s: false, d: false, arrowup: false, arrowdown: false, arrowleft: false, arrowright: false };
let mouse = { x: 0, y: 0 };
let cars = [];
let gameState = 'MENU'; 
let camera = { x: 0, y: 0 };
let cameraP2 = { x: 0, y: 0 }; 
let currentZoom = 1.0; 
let activeTrack = [];
let trackStartAngle = 0; 
let grandstands = []; 
let difficultySetting = "PRO"; 
let countdownTimer = null;

// Map & Boundary Limits
let mapMinX=0, mapMaxX=0, mapMinY=0, mapMaxY=0;
let boundMinX=0, boundMaxX=0, boundMinY=0, boundMaxY=0;
const BOUNDARY_BUFFER = 1000; 

/** UTILITIES */
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

window.addEventListener('mousemove', e => {
    mouse.x = e.clientX - width / 2;
    mouse.y = e.clientY - height / 2;
});
window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if (e.key === "Escape") togglePause();
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
window.addEventListener('click', () => {
    if(gameState === 'MENU' && audioMenu.paused) {
        audioMenu.play().catch(e => console.log("Audio waiting for interaction"));
    }
}, {once:true});

function dist(x1, y1, x2, y2) { return Math.sqrt((x2-x1)**2 + (y2-y1)**2); }

/** POPULATE MENU */
const teamSelect = document.getElementById('team-select');
TEAMS.forEach(t => {
    const opt = document.createElement('option');
    opt.value = t.id;
    opt.innerText = t.name;
    teamSelect.appendChild(opt);
});
updateTeamDesc();

// Populate MP Dropdowns
const p1MpSelect = document.getElementById('mp-p1-team');
const p2MpSelect = document.getElementById('mp-p2-team');
TEAMS.forEach(t => {
    const opt1 = document.createElement('option'); opt1.value = t.id; opt1.innerText = t.name;
    const opt2 = document.createElement('option'); opt2.value = t.id; opt2.innerText = t.name;
    p1MpSelect.appendChild(opt1);
    p2MpSelect.appendChild(opt2);
});
updateMPTeamColors();

function updateTeamDesc() {
    const id = parseInt(document.getElementById('team-select').value);
    const t = TEAMS.find(x => x.id === id);
    document.getElementById('team-desc-box').innerHTML = t.desc;
    document.getElementById('team-desc-box').style.borderLeft = `4px solid ${t.color}`;
}

function updateMPTeamColors() {
    const id1 = parseInt(document.getElementById('mp-p1-team').value);
    const t1 = TEAMS.find(x => x.id === id1);
    document.getElementById('mp-p1-preview').style.background = t1.color;
    
    const id2 = parseInt(document.getElementById('mp-p2-team').value);
    const t2 = TEAMS.find(x => x.id === id2);
    document.getElementById('mp-p2-preview').style.background = t2.color;
}

function togglePause() {
    if (gameState === 'RACING') {
        gameState = 'PAUSED';
        document.getElementById('pause-menu').classList.remove('hidden');
        audioRace.pause();
    } else if (gameState === 'PAUSED') {
        gameState = 'RACING';
        document.getElementById('pause-menu').classList.add('hidden');
        audioRace.play();
    }
}

/** RACING LINE GENERATOR */
function generateRacingLine() {
    // Attempt to load ghost data first
    if(loadGhost(currentMapKey)) {
        // Ghost data is array of {x,y,speed}
        racingLine = ghostData.map(pt => ({
            x: pt.x,
            y: pt.y,
            idealSpeed: pt.speed || 15.0 // Fallback if old format
        }));
        return;
    }

    // Fallback: Geometric Generation (WTW)
    racingLine = [];
    const pts = activeTrack;
    
    for(let i=0; i<pts.length; i++) {
        let prev = pts[(i - 1 + pts.length) % pts.length];
        let curr = pts[i];
        let next = pts[(i + 1) % pts.length];
        
        let v1x = curr.x - prev.x; let v1y = curr.y - prev.y;
        let v2x = next.x - curr.x; let v2y = next.y - curr.y;
        
        let l1 = Math.sqrt(v1x*v1x + v1y*v1y);
        let l2 = Math.sqrt(v2x*v2x + v2y*v2y);
        v1x/=l1; v1y/=l1; v2x/=l2; v2y/=l2;
        
        let dot = v1x * v2x + v1y * v2y; 
        let angle = Math.acos(Math.max(-1, Math.min(1, dot))); 
        
        let maxShift = (TRACK_WIDTH / 2) * 0.85;
        let bisectX = v1x - v2x; 
        let bisectY = v1y - v2y;
        let bl = Math.sqrt(bisectX*bisectX + bisectY*bisectY);
        let rX = curr.x;
        let rY = curr.y;

        if (bl > 0.1) {
            bisectX /= bl; bisectY /= bl;
            let factor = Math.min(angle, 1.5) / 1.5; 
            rX += bisectX * maxShift * factor;
            rY += bisectY * maxShift * factor;
        }
        racingLine.push({x: rX, y: rY, distToNext: l2, idealSpeed: 0});
    }

    // Speed Profiling for fallback line
    const MAX_THEORETICAL_SPEED = 25.0; 
    const MAX_CORNER_SPEED = 18.0; 
    const MIN_CORNER_SPEED = 4.0;
    const DECEL_FACTOR = 0.08;
    
    for(let i=0; i<racingLine.length; i++) {
        let prev = racingLine[(i - 1 + racingLine.length) % racingLine.length];
        let curr = racingLine[i];
        let next = racingLine[(i + 1) % racingLine.length];
        
        let v1x = curr.x - prev.x; let v1y = curr.y - prev.y;
        let v2x = next.x - curr.x; let v2y = next.y - curr.y;
        let l1 = Math.sqrt(v1x*v1x+v1y*v1y);
        let l2 = Math.sqrt(v2x*v2x+v2y*v2y);
        v1x/=l1; v1y/=l1; v2x/=l2; v2y/=l2;
        
        let dot = v1x*v2x + v1y*v2y; 
        
        let curvatureSpeed = MAX_THEORETICAL_SPEED;
        if (dot < 0.95) {
            let severity = (1.0 - dot) / 2.0; 
            curvatureSpeed = MIN_CORNER_SPEED + (MAX_CORNER_SPEED - MIN_CORNER_SPEED) * (1.0 - severity);
        }
        curr.idealSpeed = curvatureSpeed;
    }
    
    for(let pass=0; pass<4; pass++) {
        for(let i=racingLine.length-1; i>=0; i--) {
            let curr = racingLine[i];
            let next = racingLine[(i + 1) % racingLine.length];
            let dist = Math.sqrt((next.x-curr.x)**2 + (next.y-curr.y)**2); // recalc dist if needed
            let maxEntrySpeed = next.idealSpeed + (DECEL_FACTOR * dist);
            if (maxEntrySpeed < curr.idealSpeed) curr.idealSpeed = maxEntrySpeed;
        }
    }
}

/** CAR CLASS */
class Car {
    constructor(controlScheme, startX, startY, startAngle, teamData, skillLevel, id) {
        this.controlScheme = controlScheme; 
        this.isPlayer = (controlScheme !== 'AI');
        this.x = startX;
        this.y = startY;
        this.angle = startAngle; 
        this.vx = 0;
        this.vy = 0;
        this.color = teamData.color;
        this.id = id; 
        
        // --- TRUE TEAM SPECS FOR AI ---
        let diffSpeedMod = 1.0;
        let diffGripMod = 1.0;

        this.maxSpeed = BASE_MAX_SPEED * teamData.speed;
        this.turnRate = BASE_TURN_SPEED * teamData.handling;
        this.grip = teamData.grip;

        if (!this.isPlayer) {
            if (difficultySetting === "ROOKIE") {
                diffSpeedMod = 0.92;  
                diffGripMod = 1.0;    
            } else if (difficultySetting === "LEGEND") {
                diffSpeedMod = 1.02;  
                diffGripMod = 1.2;    
            } else {
                diffSpeedMod = 0.98;
                diffGripMod = 1.1; 
            }
            this.maxSpeed *= diffSpeedMod;
            this.grip *= diffGripMod;
        }

        this.lap = 1;
        this.raceStartTime = 0; 
        this.currentLapStart = 0;
        this.lastLapTime = 0;
        this.bestLapTime = 9999;
        this.totalRaceTime = 0; 
        this.nextWaypointIndex = 0; 
        this.finished = false;
        this.hasCrossedStartLine = false;
        this.aiSkill = skillLevel; 
        this.offTrackTimer = 0; 
        this.warningCount = 0;
        this.stopPenaltyTime = 0;
    }

    update() {
        if (gameState !== 'RACING' && gameState !== 'FINISHED' && gameState !== 'MENU') return;
        
        if (this.finished) {
            this.vx *= 0.9; this.vy *= 0.9;
            this.x += this.vx; this.y += this.vy;
            return;
        }

        if (this.stopPenaltyTime > 0) {
            this.vx = 0; this.vy = 0;
            this.stopPenaltyTime -= 1/60; 
            if (this.isPlayer) {
                if(!isMultiplayer || this.controlScheme === 'WASD') {
                     document.getElementById('penalty-overlay').classList.remove('hidden');
                     document.getElementById('penalty-timer').innerText = this.stopPenaltyTime.toFixed(1);
                }
            }
            if (this.stopPenaltyTime <= 0) {
                this.stopPenaltyTime = 0;
                if (this.isPlayer) document.getElementById('penalty-overlay').classList.add('hidden');
            } else {
                return; 
            }
        }

        const speed = Math.sqrt(this.vx**2 + this.vy**2);

        let gas = false, brake = false, turnLeft = false, turnRight = false;

        if (this.controlScheme === 'WASD' && gameState === 'RACING') {
            if (keys.w) gas = true; if (keys.s) brake = true;
            if (keys.a) turnLeft = true; if (keys.d) turnRight = true;
            // Record P1 if ghost logic active
            if(gas || brake || Math.abs(speed)>0.1) {
                currentLapRecording.push({x: this.x, y: this.y, speed: speed});
            }
        } 
        else if (this.controlScheme === 'ARROWS' && gameState === 'RACING') {
            if (keys.arrowup) gas = true; if (keys.arrowdown) brake = true;
            if (keys.arrowleft) turnLeft = true; if (keys.arrowright) turnRight = true;
        }
        else if (this.controlScheme === 'AI' || gameState === 'MENU') {
            this.runAI();
        }

        if (this.isPlayer && gameState === 'RACING') {
             if (gas) { this.vx += Math.cos(this.angle)*BASE_ACCEL; this.vy += Math.sin(this.angle)*BASE_ACCEL; }
             if (brake) { this.vx -= Math.cos(this.angle)*BASE_ACCEL*0.5; this.vy -= Math.sin(this.angle)*BASE_ACCEL*0.5; }
             if (speed > 0.5) {
                const dir = (this.vx*Math.cos(this.angle) + this.vy*Math.sin(this.angle)) > 0 ? 1 : -1;
                if (turnLeft) this.angle -= this.turnRate * dir;
                if (turnRight) this.angle += this.turnRate * dir;
             }
        }

        const onTrack = isPointInTrack(this.x, this.y);
        let friction = onTrack ? (BASE_FRICTION_ROAD * this.grip) : BASE_FRICTION_GRASS;
        if (friction > 0.99) friction = 0.99;
        this.vx *= friction; this.vy *= friction;

        let limit = this.maxSpeed;
        if (!onTrack) {
            limit = BASE_MAX_SPEED * 0.4;
            if (speed > 4) {
                this.offTrackTimer++;
                if (this.offTrackTimer % 100 === 1) this.addWarning();
            }
        } else {
            this.offTrackTimer = 0;
        }

        if (speed > limit) {
            const r = limit / speed;
            this.vx *= r; this.vy *= r;
        }

        this.x += this.vx; this.y += this.vy;

        if(this.x < boundMinX) { this.x = boundMinX + 1; this.vx *= -0.5; }
        if(this.x > boundMaxX) { this.x = boundMaxX - 1; this.vx *= -0.5; }
        if(this.y < boundMinY) { this.y = boundMinY + 1; this.vy *= -0.5; }
        if(this.y > boundMaxY) { this.y = boundMaxY - 1; this.vy *= -0.5; }

        this.checkWaypoints();
    }

    addWarning() {
        if(gameState === 'MENU') return;
        this.warningCount++;
        if (this.isPlayer) {
            let elId = (this.controlScheme === 'WASD') ? 'p1-warn-count' : 'p2-warn-count';
            const warnUi = document.getElementById(elId);
            if(warnUi) {
                warnUi.innerText = this.warningCount;
                warnUi.style.color = this.warningCount >= 4 ? "red" : "white";
            }
        }
        let limit = this.isPlayer ? 5 : 8; 
        if (this.warningCount >= limit) this.triggerPenalty();
    }

    triggerPenalty() {
        if (difficultySetting === "ROOKIE") return;
        let penaltySeconds = (difficultySetting === "PRO") ? 5 : 10;
        this.stopPenaltyTime = penaltySeconds;
        this.warningCount = 0; 
        if (this.isPlayer) {
            let elId = (this.controlScheme === 'WASD') ? 'p1-warn-count' : 'p2-warn-count';
            const warnUi = document.getElementById(elId);
            if(warnUi) warnUi.innerText = "0";
        }
    }

    runAI() {
        const speed = Math.sqrt(this.vx**2 + this.vy**2);
        
        // 1. FIND TARGET ON RACING LINE (Either Ghost or Calc)
        // Find closest point on line ahead of us
        const lookAheadDist = 200 + (speed * 12); 
        
        // Simple search for nearest node on racing line to start lookahead
        // Optimization: start search from previous known index
        let bestIdx = this.nextWaypointIndex; // Just use checkpoint logic index as approximation
        // Actually, racingLine might be much more dense (ghost data)
        // If racingLine is ghost data, it has hundreds/thousands of points.
        // We need a robust way to find "Nearest point + lookahead"
        
        // If huge array (ghost), local search
        if (racingLine.length > 500) {
            // Local search around current position
            // But we don't track an index for AI on ghost line yet.
            // Let's iterate forward from last known?
            // Simple approach: Use nextWaypointIndex which tracks TRACK nodes, mapping to line is hard.
            // Better: AI tracks its own index on the racing line.
            
            if (typeof this.aiLineIndex === 'undefined') this.aiLineIndex = 0;
            
            // Advance index until it's ahead of us
            let searchLimit = 50; 
            while(searchLimit-- > 0) {
                let curr = racingLine[this.aiLineIndex];
                if (dist(this.x, this.y, curr.x, curr.y) < 150) {
                    this.aiLineIndex = (this.aiLineIndex + 1) % racingLine.length;
                } else {
                    break; 
                }
            }
            // Look ahead
            let targetIdx = (this.aiLineIndex + 10) % racingLine.length; // +10 frames ahead
            var target = racingLine[targetIdx];
            var idealSpeed = target.idealSpeed; // Ghost speed
        } else {
            // Fallback (sparse nodes)
            let targetIndex = this.nextWaypointIndex;
            let distToNode = dist(this.x, this.y, racingLine[targetIndex].x, racingLine[targetIndex].y);
            if (distToNode < lookAheadDist) {
                let searchIndex = targetIndex;
                let currentDist = distToNode;
                while (currentDist < lookAheadDist) {
                    searchIndex = (searchIndex + 1) % racingLine.length;
                    currentDist += dist(racingLine[searchIndex].x, racingLine[searchIndex].y, 
                                        racingLine[(searchIndex-1+racingLine.length)%racingLine.length].x, 
                                        racingLine[(searchIndex-1+racingLine.length)%racingLine.length].y);
                }
                targetIndex = searchIndex;
            }
            var target = racingLine[targetIndex];
            var idealSpeed = target.idealSpeed;
        }

        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const targetAngle = Math.atan2(dy, dx);
        
        let diff = targetAngle - this.angle;
        while (diff <= -Math.PI) diff += Math.PI*2;
        while (diff > Math.PI) diff -= Math.PI*2;

        let steerSpeed = this.turnRate;
        if (diff > steerSpeed) this.angle += steerSpeed;
        else if (diff < -steerSpeed) this.angle -= steerSpeed;
        else this.angle += diff;

        // 2. SPEED MATCHING (Ghost or Profile)
        // If Ghost: idealSpeed is what player did.
        // If Profile: idealSpeed is calculated physics max.
        
        let skillFactor = 0.85 + ((this.aiSkill - 0.8) * 0.75); 
        if (difficultySetting === "LEGEND") skillFactor = 1.05; 
        
        let targetSpeed = idealSpeed * skillFactor;
        
        if (speed > targetSpeed) {
            let intensity = (speed - targetSpeed) / 5.0;
            if(intensity > 1) intensity = 1;
            this.vx *= (1.0 - (0.05 * intensity));
            this.vy *= (1.0 - (0.05 * intensity));
        } else if (speed < this.maxSpeed) {
            this.vx += Math.cos(this.angle) * BASE_ACCEL * this.aiSkill;
            this.vy += Math.sin(this.angle) * BASE_ACCEL * this.aiSkill;
        }
    }

    checkWaypoints() {
        const target = activeTrack[this.nextWaypointIndex]; 
        if (dist(this.x, this.y, target.x, target.y) < TRACK_WIDTH * 2.0) {
            this.nextWaypointIndex++;
            if (this.nextWaypointIndex >= activeTrack.length) this.nextWaypointIndex = 0;
            
            if (this.nextWaypointIndex === 1) {
                if (this.hasCrossedStartLine) {
                    this.completeLap();
                } else {
                    this.hasCrossedStartLine = true;
                }
            }
        }
    }

    completeLap() {
        const now = Date.now();
        if (this.currentLapStart > 0) {
            this.lastLapTime = (now - this.currentLapStart) / 1000;
            if(this.lastLapTime < this.bestLapTime) this.bestLapTime = this.lastLapTime;

            if (this.controlScheme === 'WASD' && gameState === 'RACING') {
                if (checkRecord(currentMapKey, this.lastLapTime)) {
                    // Save Ghost
                    saveGhost(currentMapKey, currentLapRecording);
                    
                    const n = document.getElementById('new-record-msg');
                    n.style.display = 'block';
                    setTimeout(() => n.style.display = 'none', 3000);
                    document.getElementById('track-record').innerText = formatTime(trackRecords[currentMapKey]);
                }
                // Reset recording
                currentLapRecording = [];
            }
        }
        this.currentLapStart = now;
        this.lap++;
        if (this.lap > TOTAL_LAPS) {
            if(gameState !== 'MENU') {
                this.finished = true;
                this.totalRaceTime = (now - this.raceStartTime) / 1000;
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        ctx.fillStyle = "#111";
        ctx.fillRect(10, -14, 10, 6); ctx.fillRect(10, 8, 10, 6);
        ctx.fillRect(-18, -15, 12, 8); ctx.fillRect(-18, 7, 12, 8);

        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.moveTo(22, 0); ctx.lineTo(5, -4); ctx.lineTo(5, 4); ctx.fill();
        ctx.fillRect(-10, -5, 20, 10);
        ctx.fillRect(-12, -10, 14, 6); ctx.fillRect(-12, 4, 14, 6);

        ctx.fillStyle = (this.isPlayer && gameState === 'RACING') ? "#222" : "#333";
        ctx.fillRect(20, -14, 4, 28);
        ctx.fillRect(-22, -12, 6, 24);

        ctx.fillStyle = (this.isPlayer && gameState === 'RACING') ? "#fff" : "#ff0";
        if(this.controlScheme === 'ARROWS') ctx.fillStyle = "#00f5d4"; 
        
        ctx.beginPath(); ctx.arc(-2, 0, 3.5, 0, Math.PI*2); ctx.fill();
        
        if (this.stopPenaltyTime > 0) {
            ctx.restore(); 
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.fillStyle = "#ff0000";
            ctx.font = "bold 24px monospace";
            ctx.textAlign = "center";
            ctx.shadowColor = "black";
            ctx.shadowBlur = 4;
            ctx.fillText("PENALTY", 0, -30);
        }

        ctx.restore();
    }
}

/** GAME SYSTEM */

function isPointInTrack(px, py) {
    for (let i = 0; i < activeTrack.length - 1; i++) {
        if (distToSegment(px, py, activeTrack[i].x, activeTrack[i].y, activeTrack[i+1].x, activeTrack[i+1].y) < TRACK_WIDTH/2) return true;
    }
    if (distToSegment(px, py, activeTrack[activeTrack.length-1].x, activeTrack[activeTrack.length-1].y, activeTrack[0].x, activeTrack[0].y) < TRACK_WIDTH/2) return true;
    return false;
}

function distToSegment(x, y, x1, y1, x2, y2) {
    const A = x - x1; const B = y - y1;
    const C = x2 - x1; const D = y2 - y1;
    const dot = A * C + B * D;
    const len_sq = C * C + D * D;
    let param = -1;
    if (len_sq != 0) param = dot / len_sq;
    let xx, yy;
    if (param < 0) { xx = x1; yy = y1; }
    else if (param > 1) { xx = x2; yy = y2; }
    else { xx = x1 + param * C; yy = y1 + param * D; }
    const dx = x - xx; const dy = y - yy;
    return Math.sqrt(dx * dx + dy * dy);
}

function calculateTrackExtents() {
    mapMinX = Infinity; mapMaxX = -Infinity;
    mapMinY = Infinity; mapMaxY = -Infinity;
    
    activeTrack.forEach(p => {
        if(p.x < mapMinX) mapMinX = p.x;
        if(p.x > mapMaxX) mapMaxX = p.x;
        if(p.y < mapMinY) mapMinY = p.y;
        if(p.y > mapMaxY) mapMaxY = p.y;
    });

    boundMinX = mapMinX - BOUNDARY_BUFFER;
    boundMaxX = mapMaxX + BOUNDARY_BUFFER;
    boundMinY = mapMinY - BOUNDARY_BUFFER;
    boundMaxY = mapMaxY + BOUNDARY_BUFFER;
}

function generateGrandstands() {
    grandstands = [];
    const points = activeTrack;
    calculateTrackExtents(); 

    const addStand = (p1, p2) => {
        const d = dist(p1.x, p1.y, p2.x, p2.y);
        if (d > 400) { 
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            const offsetX = Math.cos(angle + Math.PI/2) * (TRACK_WIDTH/2 + 30);
            const offsetY = Math.sin(angle + Math.PI/2) * (TRACK_WIDTH/2 + 30);
            grandstands.push({ x: p1.x + offsetX, y: p1.y + offsetY, w: d, h: 40, angle: angle });
        }
    };
    for(let i=0; i<points.length-1; i++) addStand(points[i], points[i+1]);
    addStand(points[points.length-1], points[0]);
    
    generateDecorations();
    generateRacingLine(); // Load Ghost or Fallback
}

function generateDecorations() {
    if(!drawDecorationsEnabled) {
        decorations = [];
        return;
    }
    
    decorations = [];
    const numItems = 200;
    
    for(let i=0; i<numItems; i++) {
        const x = mapMinX - 500 + Math.random() * (mapMaxX - mapMinX + 1000);
        const y = mapMinY - 500 + Math.random() * (mapMaxY - mapMinY + 1000);
        
        if (!isPointInTrack(x, y)) {
            const type = Math.random() > 0.7 ? 'ROCK' : 'TREE';
            const size = 20 + Math.random() * 30;
            const angle = Math.random() * Math.PI * 2;
            decorations.push({x, y, type, size, angle});
        }
    }
}

function drawDecorations(ctx) {
    if(!drawDecorationsEnabled) return;
    
    ctx.save();
    decorations.forEach(d => {
        ctx.translate(d.x, d.y);
        ctx.rotate(d.angle);
        
        if(d.type === 'TREE') {
            ctx.fillStyle = "rgba(0,0,0,0.3)";
            ctx.beginPath(); ctx.arc(5, 5, d.size/2, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#1b4d1b"; 
            ctx.beginPath(); ctx.arc(0, 0, d.size/2, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#2d6a2d"; 
            ctx.beginPath(); ctx.arc(-2, -2, d.size/3, 0, Math.PI*2); ctx.fill();
        } else {
            ctx.fillStyle = "#555";
            ctx.fillRect(-d.size/2, -d.size/2, d.size, d.size);
            ctx.fillStyle = "#777";
            ctx.fillRect(-d.size/2 + 2, -d.size/2 + 2, d.size-4, d.size-4);
        }
        
        ctx.rotate(-d.angle);
        ctx.translate(-d.x, -d.y);
    });
    ctx.restore();
}

function showMenu() {
    gameState = 'MENU';
    audioRace.pause();
    audioRace.currentTime = 0;
    audioMenu.play().catch(e => { });

    document.getElementById('main-menu').classList.remove('hidden');
    document.getElementById('multiplayer-menu').classList.add('hidden');
    document.getElementById('pause-menu').classList.add('hidden');
    document.getElementById('ui-layer').classList.add('hidden');
    document.getElementById('results-menu').classList.add('hidden');
    document.getElementById('champ-menu').classList.add('hidden');
    document.getElementById('penalty-overlay').classList.add('hidden');
    document.getElementById('leaderboard-view').classList.add('hidden');
    document.getElementById('new-record-msg').style.display = 'none';

    activeTrack = MAPS["SILVERSTONE"]; 
    generateGrandstands(); 
    setupGrid(true); 
}

function startCareer() {
    isCareerMode = true;
    isMultiplayer = false;
    careerIndex = 0;
    careerScores = new Array(TOTAL_CARS).fill(0);
    playerCareerPoints = 0;
    
    difficultySetting = document.getElementById('diff-select').value;
    selectedTeamId = parseInt(document.getElementById('team-select').value);

    // 1. Generate Seat Pool for Career (2 per team)
    let seatPool = [];
    TEAMS.forEach(t => { seatPool.push(t.id); seatPool.push(t.id); });

    // 2. Assign Player
    careerParticipants = new Array(TOTAL_CARS);
    let p1Index = TOTAL_CARS - 1;
    
    // Remove Player Seat from Pool
    let idx = seatPool.indexOf(selectedTeamId);
    if(idx > -1) seatPool.splice(idx, 1);
    
    // Assign Player Participant
    let pTeam = TEAMS.find(t => t.id === selectedTeamId);
    careerParticipants[p1Index] = {
        id: p1Index,
        name: "PLAYER",
        teamId: selectedTeamId,
        color: pTeam.color
    };

    // 3. Shuffle remaining AI seats
    seatPool.sort(() => Math.random() - 0.5);

    // 4. Fill AI Slots
    for(let i = 0; i < TOTAL_CARS - 1; i++) {
        let tId = seatPool.pop();
        let t = TEAMS.find(x => x.id === tId);
        careerParticipants[i] = {
            id: i,
            name: "CPU " + (i+1),
            teamId: tId,
            color: t.color
        };
    }

    setupCareerRace();
}

function setupCareerRace() {
    currentMapKey = CAREER_ORDER[careerIndex];
    activeTrack = MAPS[currentMapKey];
    generateGrandstands();

    audioMenu.pause();
    audioMenu.currentTime = 0;
    audioRace.play();

    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('ui-layer').classList.remove('hidden');
    document.getElementById('results-menu').classList.add('hidden');
    document.getElementById('penalty-overlay').classList.add('hidden');
    document.getElementById('leaderboard-view').classList.add('hidden');
    
    document.getElementById('career-overlay').classList.remove('hidden');
    document.getElementById('career-overlay').innerText = `ROUND ${careerIndex+1}/${CAREER_ORDER.length}: ${currentMapKey}`;
    
    configureHUD();
    document.getElementById('track-record').innerText = formatTime(trackRecords[currentMapKey]);

    setupGrid(false);
    startCountdown();
}

function nextCareerRace() {
    careerIndex++;
    if (careerIndex < CAREER_ORDER.length) {
        setupCareerRace();
    } else {
        showChampionshipResult();
    }
}

function showChampionshipResult() {
    gameState = 'MENU'; 
    document.getElementById('results-menu').classList.add('hidden');
    document.getElementById('champ-menu').classList.remove('hidden');
    
    let maxPoints = -1;
    let winnerId = -1;
    
    for(let i=0; i<TOTAL_CARS; i++) {
        if(careerScores[i] > maxPoints) {
            maxPoints = careerScores[i];
            winnerId = i;
        }
    }
    
    const champName = document.getElementById('champ-name');
    if (winnerId === TOTAL_CARS-1) {
        champName.innerText = "PLAYER";
        champName.style.color = "#00ff00";
    } else {
        champName.innerText = "AI DRIVER";
        champName.style.color = "#e63946";
    }
    
    document.getElementById('champ-points').innerText = maxPoints;
    renderLeaderboard();
}

function toggleLeaderboard() {
    const el = document.getElementById('leaderboard-view');
    if (el.classList.contains('hidden')) {
        renderLeaderboard();
        el.classList.remove('hidden');
    } else {
        el.classList.add('hidden');
    }
}

function renderLeaderboard() {
    const tbody = document.getElementById('leaderboard-body');
    tbody.innerHTML = "";
    
    let ranking = [];
    for(let i=0; i<TOTAL_CARS; i++) {
        let p = careerParticipants[i];
        if(!p) continue; 
        let teamName = TEAMS.find(t => t.id === p.teamId).name;
        ranking.push({
            name: p.name,
            team: teamName,
            points: careerScores[i],
            isPlayer: (i === TOTAL_CARS-1)
        });
    }
    
    ranking.sort((a,b) => b.points - a.points);
    
    ranking.forEach((r, idx) => {
        const row = document.createElement('tr');
        if(r.isPlayer) row.classList.add('player-row');
        row.innerHTML = `
            <td>${idx+1}</td>
            <td>${r.name}</td>
            <td>${r.team}</td>
            <td style="text-align:right;">${r.points}</td>
        `;
        tbody.appendChild(row);
    });
}

function openMultiplayerMenu() {
    // Hide main menu, show MP submenu
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('multiplayer-menu').classList.remove('hidden');
}

function startMultiplayerRace() {
    isCareerMode = false;
    isMultiplayer = true;

    // Get MP Specific Selections
    currentMapKey = document.getElementById('mp-map-select').value;
    selectedTeamId = parseInt(document.getElementById('mp-p1-team').value);
    selectedP2TeamId = parseInt(document.getElementById('mp-p2-team').value);
    
    // Difficulty from main menu still applies
    difficultySetting = document.getElementById('diff-select').value;
    
    activeTrack = MAPS[currentMapKey];
    generateGrandstands();

    audioMenu.pause();
    audioMenu.currentTime = 0;
    audioRace.play();

    document.getElementById('multiplayer-menu').classList.add('hidden');
    document.getElementById('ui-layer').classList.remove('hidden');
    document.getElementById('career-overlay').classList.add('hidden');
    document.getElementById('results-menu').classList.add('hidden');
    document.getElementById('penalty-overlay').classList.add('hidden');
    document.getElementById('leaderboard-view').classList.add('hidden');
    document.getElementById('dev-recording-ui').style.display = 'none';
    
    document.getElementById('track-record').innerText = formatTime(trackRecords[currentMapKey]);
    
    configureHUD();
    setupGrid(false);
    startCountdown();
}

function startGame(isQuickRace) {
    if (isQuickRace) {
        isCareerMode = false;
        isMultiplayer = false;
        currentMapKey = document.getElementById('map-select').value;
        difficultySetting = document.getElementById('diff-select').value;
        selectedTeamId = parseInt(document.getElementById('team-select').value);
        
        activeTrack = MAPS[currentMapKey];
        generateGrandstands();

        audioMenu.pause();
        audioMenu.currentTime = 0;
        audioRace.play();

        document.getElementById('main-menu').classList.add('hidden');
        document.getElementById('ui-layer').classList.remove('hidden');
        document.getElementById('career-overlay').classList.add('hidden');
        document.getElementById('results-menu').classList.add('hidden');
        document.getElementById('penalty-overlay').classList.add('hidden');
        document.getElementById('leaderboard-view').classList.add('hidden');
        
        // Show recording UI
        document.getElementById('dev-recording-ui').style.display = 'block';
        currentLapRecording = [];
        
        document.getElementById('track-record').innerText = formatTime(trackRecords[currentMapKey]);
        
        configureHUD();
        setupGrid(false);
        startCountdown();
    }
}

function configureHUD() {
    document.getElementById('p1-warn-count').innerText = "0";
    document.getElementById('p2-warn-count').innerText = "0";
    document.getElementById('p1-warn-limit').innerText = "5"; 

    if (isMultiplayer) {
        document.getElementById('p1-hud').style.width = "50%";
        document.getElementById('p1-hud').style.borderRight = "2px solid #000";
        document.getElementById('p2-hud').style.display = "block";
    } else {
        document.getElementById('p1-hud').style.width = "100%";
        document.getElementById('p1-hud').style.borderRight = "none";
        document.getElementById('p2-hud').style.display = "none";
    }
}

function restartRace() {
    if (isCareerMode) {
        setupCareerRace(); 
    } else if (isMultiplayer) {
        startMultiplayerRace(); // Use the MP starter logic
    } else {
        startGame(true);
    }
}

function setupGrid(isDemo) {
    cars = [];
    const pEnd = activeTrack[activeTrack.length - 1];
    const pStart = activeTrack[0];
    trackStartAngle = Math.atan2(pStart.y - pEnd.y, pStart.x - pEnd.x);
    const backAngle = trackStartAngle + Math.PI;
    const sideAngle = trackStartAngle + Math.PI/2; 

    // ---- GRID GENERATION LOGIC (2 Cars Per Team) ----
    
    // 1. Create a pool of seats (2 per team ID)
    let seatPool = [];
    TEAMS.forEach(t => { seatPool.push(t.id); seatPool.push(t.id); });

    // 2. Identify Player Slots and remove from pool
    let gridSlots = new Array(TOTAL_CARS).fill(null);
    let p1Index = TOTAL_CARS - 1;
    let p2Index = TOTAL_CARS - 2; // Only used if MP

    if (!isDemo) {
        if (isCareerMode) {
            // Use pre-defined participants
            for(let i=0; i<TOTAL_CARS; i++) {
                gridSlots[i] = { type: (i===p1Index ? 'P1' : 'AI'), teamId: careerParticipants[i].teamId };
            }
        } else {
            // Quick Race / MP: Remove P1 Selection
            let idx = seatPool.indexOf(selectedTeamId);
            if (idx > -1) seatPool.splice(idx, 1);
            gridSlots[p1Index] = { type: 'P1', teamId: selectedTeamId };

            if (isMultiplayer) {
                // Remove P2 Selection
                let idx2 = seatPool.indexOf(selectedP2TeamId);
                if (idx2 > -1) {
                    seatPool.splice(idx2, 1);
                    gridSlots[p2Index] = { type: 'P2', teamId: selectedP2TeamId };
                } else {
                    let rnd = seatPool.pop();
                    gridSlots[p2Index] = { type: 'P2', teamId: rnd };
                }
            }
            
            // Shuffle AI
            seatPool.sort(() => Math.random() - 0.5);

            // Assign remaining
            for(let i=0; i<TOTAL_CARS; i++) {
                if(!gridSlots[i]) {
                    gridSlots[i] = { type: 'AI', teamId: seatPool.pop() };
                }
            }
        }
    } else {
        // Demo Mode - Just shuffle everyone
        seatPool.sort(() => Math.random() - 0.5);
        for(let i=0; i<TOTAL_CARS; i++) {
            gridSlots[i] = { type: 'AI', teamId: seatPool.pop() };
        }
    }

    // ---- INSTANTIATION ----
    for (let i = 0; i < TOTAL_CARS; i++) {
        let slot = gridSlots[i];
        let control = 'AI';

        if (!isDemo) {
            if (slot.type === 'P1') control = 'WASD';
            if (slot.type === 'P2') control = 'ARROWS';
        }

        const row = Math.floor(i / 2);
        const col = i % 2; 
        
        const distBack = 300 + (row * 90);
        const latOffset = (col === 0 ? -1 : 1) * 35;
        
        const startX = pStart.x + (Math.cos(backAngle) * distBack) + (Math.cos(sideAngle) * latOffset);
        const startY = pStart.y + (Math.sin(backAngle) * distBack) + (Math.sin(sideAngle) * latOffset);
        
        let team = TEAMS.find(t => t.id === slot.teamId);
        
        let skill = 1.0;
        if(difficultySetting === "ROOKIE") skill = 0.85;
        if(difficultySetting === "LEGEND") skill = 1.1;
        if (isDemo) skill = 0.8; 

        cars.push(new Car(control, startX, startY, trackStartAngle, team, skill, i));
    }

    if(cars.length > 0) {
        if (isDemo) {
            camera.x = cars[0].x;
            camera.y = cars[0].y;
        } else {
            const p1 = cars.find(c => c.controlScheme === 'WASD');
            if(p1) { camera.x = p1.x; camera.y = p1.y; }
            
            if(isMultiplayer) {
                const p2 = cars.find(c => c.controlScheme === 'ARROWS');
                if(p2) { cameraP2.x = p2.x; cameraP2.y = p2.y; }
            }
        }
    }
}

function startCountdown() {
    gameState = 'COUNTDOWN';
    const ui = document.getElementById('center-msg');
    ui.innerText = "";
    
    let count = 4;
    if(countdownTimer) clearInterval(countdownTimer);
    
    countdownTimer = setInterval(() => {
        count--;
        if (count > 0) {
            ui.innerText = count;
            ui.style.color = "red";
        } else {
            clearInterval(countdownTimer);
            ui.innerText = "GO!";
            ui.style.color = "#00ff00";
            gameState = 'RACING';
            const now = Date.now();
            
            cars.forEach(c => {
                c.currentLapStart = now;
                c.raceStartTime = now;
            });
            
            setTimeout(() => { if(gameState==='RACING') ui.innerText = ""; }, 1000);
        }
    }, 1000);
}

function drawTrack(ctx) {
    ctx.save();
    
    drawDecorations(ctx);

    ctx.lineWidth = 20;
    ctx.strokeStyle = "rgba(255, 255, 0, 0.2)"; 
    ctx.strokeRect(boundMinX, boundMinY, boundMaxX-boundMinX, boundMaxY-boundMinY);
    
    ctx.beginPath();
    ctx.rect(boundMinX, boundMinY, boundMaxX-boundMinX, boundMaxY-boundMinY);
    ctx.clip(); 
    
    const drawCautionLine = (x1, y1, x2, y2) => {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
        ctx.strokeStyle = "yellow"; ctx.lineWidth = 10; ctx.stroke();
        ctx.strokeStyle = "black"; ctx.setLineDash([20, 20]); ctx.stroke();
        ctx.restore();
    };
    
    drawCautionLine(boundMinX, boundMinY, boundMaxX, boundMinY);
    drawCautionLine(boundMaxX, boundMinY, boundMaxX, boundMaxY);
    drawCautionLine(boundMaxX, boundMaxY, boundMinX, boundMaxY);
    drawCautionLine(boundMinX, boundMaxY, boundMinX, boundMinY);
    
    grandstands.forEach(g => {
        ctx.translate(g.x, g.y);
        ctx.rotate(g.angle);
        ctx.fillStyle = "#555"; 
        ctx.fillRect(0, 0, g.w, g.h);
        ctx.fillStyle = `hsl(${Date.now() % 360}, 60%, 50%)`; 
        for(let i=0; i<g.w; i+=10) {
             if(Math.random()>0.5) ctx.fillRect(i, 5, 4, 4);
             if(Math.random()>0.5) ctx.fillRect(i, 15, 4, 4);
        }
        ctx.rotate(-g.angle);
        ctx.translate(-g.x, -g.y);
    });
    ctx.restore();

    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    
    ctx.strokeStyle = "#fff"; ctx.lineWidth = TRACK_WIDTH + 24;
    ctx.beginPath(); ctx.moveTo(activeTrack[0].x, activeTrack[0].y);
    activeTrack.forEach(p => ctx.lineTo(p.x, p.y)); ctx.closePath(); ctx.stroke();
    
    ctx.strokeStyle = "#e60000"; ctx.setLineDash([40, 40]);
    ctx.stroke(); ctx.setLineDash([]);
    
    ctx.strokeStyle = "#333"; ctx.lineWidth = TRACK_WIDTH;
    ctx.beginPath(); ctx.moveTo(activeTrack[0].x, activeTrack[0].y);
    activeTrack.forEach(p => ctx.lineTo(p.x, p.y)); ctx.closePath(); ctx.stroke();

    if (gameState === 'RACING' && cars.length > 0) {
        const player = cars.find(c => c.isPlayer);
        if (player) {
            let minDist = Infinity;
            
            for (let i = 0; i < activeTrack.length - 1; i++) {
                let d = distToSegment(player.x, player.y, activeTrack[i].x, activeTrack[i].y, activeTrack[i+1].x, activeTrack[i+1].y);
                if(d < minDist) minDist = d;
            }
            let dLast = distToSegment(player.x, player.y, activeTrack[activeTrack.length-1].x, activeTrack[activeTrack.length-1].y, activeTrack[0].x, activeTrack[0].y);
            if(dLast < minDist) minDist = dLast;

            let lineColor = "#ff0000"; 
            if (minDist < 25) lineColor = "#00ff00"; 
            else if (minDist < 60) lineColor = "#ffff00"; 
            
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = 6;
            ctx.setLineDash([30, 30]);
            ctx.beginPath();
            ctx.moveTo(activeTrack[0].x, activeTrack[0].y);
            activeTrack.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    if (gameState === 'COUNTDOWN') {
        ctx.strokeStyle = "rgba(0, 255, 255, 0.3)";
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.moveTo(activeTrack[0].x, activeTrack[0].y);
        activeTrack.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.closePath();
        ctx.stroke();
    }

    ctx.save();
    const pStart = activeTrack[0];
    ctx.translate(pStart.x, pStart.y);
    ctx.rotate(trackStartAngle + Math.PI/2); 
    
    ctx.fillStyle = "white"; 
    ctx.fillRect(-TRACK_WIDTH/2, -10, TRACK_WIDTH, 20);
    for(let r=0; r<2; r++){
        for(let c=0; c<10; c++){
             ctx.fillStyle = (r+c)%2===0 ? "black" : "white";
             ctx.fillRect(-TRACK_WIDTH/2 + (c*TRACK_WIDTH/10), -10 + (r*10), TRACK_WIDTH/10, 10);
        }
    }
    ctx.restore();
    
    if(gameState === 'COUNTDOWN' || gameState === 'START') {
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        const backAngle = trackStartAngle + Math.PI;
        const sideAngle = trackStartAngle + Math.PI/2;
        
        for(let i=0; i<TOTAL_CARS; i++) {
            const row = Math.floor(i / 2);
            const col = i % 2; 
            const distBack = 300 + (row * 90);
            const latOffset = (col === 0 ? -1 : 1) * 35;
            
            const gx = pStart.x + (Math.cos(backAngle) * distBack) + (Math.cos(sideAngle) * latOffset);
            const gy = pStart.y + (Math.sin(backAngle) * distBack) + (Math.sin(sideAngle) * latOffset);
            
            ctx.save();
            ctx.translate(gx, gy);
            ctx.rotate(trackStartAngle);
            ctx.fillRect(-15, -15, 30, 30);
            ctx.restore();
        }
    }
}

function drawMiniMap() {
    if(gameState === 'MENU') return;

    const mapSize = 200;
    const margin = 20;
    // Map is now Top Center in multiplayer, bottom left otherwise
    let originX = margin;
    let originY = height - mapSize - margin;
    
    if (isMultiplayer) {
        originX = width/2 - mapSize/2;
        originY = 20; // Top
    }

    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.strokeStyle = "#e63946";
    ctx.lineWidth = 2;
    ctx.fillRect(originX, originY, mapSize, mapSize);
    ctx.strokeRect(originX, originY, mapSize, mapSize);

    const viewMinX = mapMinX - 200;
    const viewMaxX = mapMaxX + 200;
    const viewMinY = mapMinY - 200;
    const viewMaxY = mapMaxY + 200;

    const mapW = viewMaxX - viewMinX;
    const mapH = viewMaxY - viewMinY;
    const scale = Math.min((mapSize - 20) / mapW, (mapSize - 20) / mapH);

    const toMapX = (val) => originX + 10 + (val - viewMinX) * scale;
    const toMapY = (val) => originY + 10 + (val - viewMinY) * scale;

    ctx.beginPath();
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 4;
    if(activeTrack.length > 0) {
        ctx.moveTo(toMapX(activeTrack[0].x), toMapY(activeTrack[0].y));
        activeTrack.forEach(p => ctx.lineTo(toMapX(p.x), toMapY(p.y)));
        ctx.closePath();
    }
    ctx.stroke();

    cars.forEach(c => {
        const mx = toMapX(c.x);
        const my = toMapY(c.y);
        ctx.beginPath();
        ctx.arc(mx, my, c.isPlayer ? 4 : 2, 0, Math.PI*2);
        
        if (c.controlScheme === 'WASD') ctx.fillStyle = "#e63946"; 
        else if (c.controlScheme === 'ARROWS') ctx.fillStyle = "#00f5d4"; 
        else ctx.fillStyle = "white"; 
        
        ctx.fill();
    });
}

function updateUI() {
    if (gameState !== 'RACING' && gameState !== 'FINISHED') return;

    const sorted = [...cars].sort((a,b) => {
        if (a.finished && b.finished) return a.totalRaceTime - b.totalRaceTime;
        if (a.finished) return -1;
        if (b.finished) return 1;
        
        if (a.lap !== b.lap) return b.lap - a.lap;
        if (a.nextWaypointIndex !== b.nextWaypointIndex) {
            return b.nextWaypointIndex - a.nextWaypointIndex;
        }
        
        let distA = dist(a.x, a.y, activeTrack[a.nextWaypointIndex].x, activeTrack[a.nextWaypointIndex].y);
        let distB = dist(b.x, b.y, activeTrack[b.nextWaypointIndex].x, activeTrack[b.nextWaypointIndex].y);
        return distA - distB; 
    });

    const updatePlayerHUD = (player, prefix) => {
        const speed = Math.sqrt(player.vx**2 + player.vy**2) * 20; 
        document.getElementById(`${prefix}-speed`).innerText = Math.floor(speed);
        
        let gear = "1";
        if(speed > 50) gear = "2"; if(speed > 100) gear = "3";
        if(speed > 160) gear = "4"; if(speed > 220) gear = "5";
        if(speed > 270) gear = "6"; if(player.finished) gear = "N";
        document.getElementById(`${prefix}-gear`).innerText = gear;

        const rank = sorted.indexOf(player) + 1;
        
        document.getElementById(`${prefix}-pos-disp`).innerText = rank;
        document.getElementById(`${prefix}-lap-disp`).innerText = Math.min(player.lap, TOTAL_LAPS);
        
        const now = Date.now();
        const curTime = (now - player.currentLapStart) / 1000;
        if(!player.finished && gameState === 'RACING') document.getElementById(`${prefix}-cur-time`).innerText = curTime.toFixed(2);
        if (player.lastLapTime > 0) document.getElementById(`${prefix}-last-lap`).innerText = player.lastLapTime.toFixed(2);
        
        return {rank, player};
    };

    let p1 = cars.find(c => c.controlScheme === 'WASD');
    if (p1) {
        let res = updatePlayerHUD(p1, 'p1');
        
        if (p1.finished && gameState !== 'FINISHED') {
             gameState = 'FINISHED';
             showFinishScreen(res.rank, p1);
        }
    }

    if (isMultiplayer) {
        let p2 = cars.find(c => c.controlScheme === 'ARROWS');
        if (p2) updatePlayerHUD(p2, 'p2');
    }
}

function showFinishScreen(rank, player) {
    document.getElementById('results-menu').classList.remove('hidden');
    document.getElementById('res-pos').innerText = "P" + rank;
    document.getElementById('res-pos').style.color = (rank <= 3) ? "#00ff00" : "#e63946";
    
    const tTime = player.totalRaceTime;
    let mins = Math.floor(tTime / 60);
    let secs = (tTime % 60).toFixed(2);
    document.getElementById('res-time').innerText = (mins > 0 ? mins + ":" : "") + (secs < 10 && mins > 0 ? "0" : "") + secs;
    
    let bMins = Math.floor(player.bestLapTime / 60);
    let bSecs = (player.bestLapTime % 60).toFixed(2);
    if(player.bestLapTime < 900) {
            document.getElementById('res-best').innerText = (bMins > 0 ? bMins + ":" : "") + (bSecs < 10 && bMins > 0 ? "0" : "") + bSecs;
    } else {
            document.getElementById('res-best').innerText = "--:--";
    }

    if (isCareerMode) {
        document.getElementById('career-result-panel').classList.remove('hidden');
        document.getElementById('btn-next').classList.remove('hidden');
        document.getElementById('btn-standings').classList.remove('hidden');
        document.getElementById('btn-restart').innerText = "RESTART LEVEL";
        
        const sorted = [...cars].sort((a,b) => {
             if (a.finished && b.finished) return a.totalRaceTime - b.totalRaceTime;
             return 0; 
        });

        let pts = 0;
        for(let i=0; i<sorted.length; i++) {
            let p = 0;
            if (i < 10) p = POINTS_SYSTEM[i];
            careerScores[sorted[i].id] += p;
            if(sorted[i].isPlayer) pts = p;
        }
        
        document.getElementById('res-pts').innerText = "+" + pts;
        document.getElementById('res-total-pts').innerText = careerScores[TOTAL_CARS-1]; 

        if (careerIndex === CAREER_ORDER.length - 1) {
            document.getElementById('btn-next').innerText = "FINISH SEASON";
        } else {
            document.getElementById('btn-next').innerText = "NEXT RACE";
        }
    } else {
        document.getElementById('career-result-panel').classList.add('hidden');
        document.getElementById('btn-next').classList.add('hidden');
        document.getElementById('btn-standings').classList.add('hidden');
        document.getElementById('btn-restart').innerText = "RESTART";
    }
}

function renderScene(targetCar, cam) {
    let targetX = targetCar.x + (gameState === 'MENU' ? 0 : mouse.x * 0.4);
    let targetY = targetCar.y + (gameState === 'MENU' ? 0 : mouse.y * 0.4);
    
    let s = Math.sqrt(targetCar.vx**2 + targetCar.vy**2);
    let pct = Math.min(s / targetCar.maxSpeed, 1.0);
    let targetZoom = 1.8 - (pct * 1.0); 
    
    cam.x += (targetX - cam.x) * 0.1;
    cam.y += (targetY - cam.y) * 0.1;

    ctx.save();
    ctx.translate(width/2, height/2); 
    
    // Dynamic Camera Rotation Logic
    if (cameraRotationEnabled) {
        // Rotate world opposite to car angle to keep car pointing Up
        // Car 0 angle = Right. Screen Up is -PI/2.
        // We want 0 -> -PI/2.
        ctx.rotate(-targetCar.angle - Math.PI/2);
    }

    ctx.scale(targetZoom, targetZoom); 
    ctx.translate(-cam.x, -cam.y);
    
    drawTrack(ctx);
    if (gameState !== 'PAUSED' && gameState !== 'MENU') {
    }
    cars.forEach(c => c.draw());
    ctx.restore();
}

function loop() {
    requestAnimationFrame(loop);

    const now = Date.now();
    const elapsed = now - lastFrameTime;

    if (elapsed > FRAME_INTERVAL) {
        lastFrameTime = now - (elapsed % FRAME_INTERVAL);

        ctx.fillStyle = "#203a20"; 
        ctx.fillRect(0, 0, width, height);
        
        if (gameState !== 'PAUSED') {
            cars.forEach(c => c.update());
        }

        if (isMultiplayer && gameState !== 'MENU') {
            const p1 = cars.find(c => c.controlScheme === 'WASD');
            const p2 = cars.find(c => c.controlScheme === 'ARROWS');

            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 0, width/2, height);
            ctx.clip();
            
            ctx.translate(-width/4, 0); 
            if(p1) renderScene(p1, camera);
            ctx.restore();
            
            ctx.beginPath();
            ctx.moveTo(width/2, 0); ctx.lineTo(width/2, height);
            ctx.lineWidth = 4; ctx.strokeStyle = "#000"; ctx.stroke();

            ctx.save();
            ctx.beginPath();
            ctx.rect(width/2, 0, width/2, height);
            ctx.clip();
            
            ctx.translate(width/4, 0);
            if(p2) renderScene(p2, cameraP2);
            ctx.restore();

        } else {
            const followCar = (gameState === 'MENU' && cars.length > 0) ? cars[0] : cars.find(c => c.controlScheme === 'WASD');
            if(followCar) renderScene(followCar, camera);
        }
        
        drawMiniMap();
        updateUI();
    }
}

showMenu();
loop();
</script>
</body>
</html>
